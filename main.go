package main

import (
	"bufio"
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/pem"
	"errors"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/jackc/pgx/v5"
	"github.com/spf13/pflag"
)

var (
	host        string
	port        int
	service     string
	database    string
	user        string
	sslmode     string
	sslcert     string
	sslkey      string
	sslrootcert string
	keylog      string
)

func init() {
	pflag.StringVarP(&host, "host", "H", "", "Database host")
	pflag.IntVarP(&port, "port", "P", 5432, "Database port")
	pflag.StringVarP(&service, "service", "S", "", "PG Service name")
	pflag.StringVarP(&database, "dbname", "d", "", "Database name")
	pflag.StringVarP(&user, "user", "U", "", "Database user")
	pflag.StringVar(&sslmode, "sslmode", "", "SSL mode")
	pflag.StringVar(&sslcert, "sslcert", "", "Path to the SSL client certificate")
	pflag.StringVar(&sslkey, "sslkey", "", "Path to the SSL client key")
	pflag.StringVar(&sslrootcert, "sslrootcert", "", "Path to the SSL root certificate")
	pflag.StringVar(&keylog, "keylog", "/var/tmp/SSLKEYLOGFILE", "Path to the SSL keylog file")
	pflag.Parse()

	// Use environment variables if CLI arguments are not provided
	if host == "" {
		host = os.Getenv("PGHOST")
	}
	if port == 5432 {
		envPort := os.Getenv("PGPORT")
		if envPort != "" {
			fmt.Sscanf(envPort, "%d", &port)
		}
	}
	if service == "" {
		service = os.Getenv("PGSERVICE")
	}
	if database == "" {
		database = os.Getenv("PGDATABASE")
	}
	if user == "" {
		user = os.Getenv("PGUSER")
	}
	if sslmode == "" {
		sslmode = os.Getenv("PGSSLMODE")
	}
	if sslcert == "" {
		sslcert = os.Getenv("PGSSLCERT")
	}
	if sslkey == "" {
		sslkey = os.Getenv("PGSSLKEY")
	}
	if sslrootcert == "" {
		sslrootcert = os.Getenv("PGSSLROOTCERT")
	}
	if keylog == "" {
		keylog = os.Getenv("SSLKEYLOGFILE")
	}
}

func main() {
	if service == "" {
		fmt.Println("Error: PG service name must be specified")
		os.Exit(1)
	}

	pgServiceConfPath := filepath.Join(os.Getenv("HOME"), ".pg_service.conf")
	serviceConfig, err := readPGServiceConfig(pgServiceConfPath, service)
	if err != nil {
		fmt.Printf("Error reading PG service config: %v\n", err)
		os.Exit(1)
	}

	// Override parameters from service config if not provided via CLI
	if host == "" {
		host = serviceConfig["host"]
	}
	if database == "" {
		database = serviceConfig["dbname"]
	}
	if user == "" {
		user = serviceConfig["user"]
	}
	if sslmode == "" {
		sslmode = serviceConfig["sslmode"]
	}
	if sslcert == "" {
		sslcert = serviceConfig["sslcert"]
	}
	if sslkey == "" {
		sslkey = serviceConfig["sslkey"]
	}
	if sslrootcert == "" {
		sslrootcert = serviceConfig["sslrootcert"]
	}

	// Load client certificate and key
	clientCert, err := os.ReadFile(sslcert)
	if err != nil {
		log.Fatalf("Failed to read client certificate file: %v", err)
	}

	clientKey, err := os.ReadFile(sslkey)
	if err != nil {
		log.Fatalf("Failed to read client key file: %v", err)
	}

	// Load root CA cert
	rootCertPool := x509.NewCertPool()
	rootCert, err := os.ReadFile(sslrootcert)
	if err != nil {
		fmt.Printf("Error loading root certificate: %v\n", err)
		os.Exit(1)
	}

	ok := rootCertPool.AppendCertsFromPEM(rootCert)
	if !ok {
		fmt.Printf("Failed to append root certificate to pool\n")
		os.Exit(1)
	}

	// DEBUG: output to verify root CA certs
	fmt.Println("Loaded Root CA Certificates:")
	rootsPEM := rootCert
	for {
		var block *pem.Block
		block, rootsPEM = pem.Decode(rootsPEM)
		if block == nil {
			break
		}
		if block.Type == "CERTIFICATE" {
			caCert, err := x509.ParseCertificate(block.Bytes)
			if err != nil {
				fmt.Printf("Error parsing certificate: %v\n", err)
				os.Exit(1)
			}
			fmt.Printf("\tSubject: %s\n", caCert.Subject)
		}
	}

	// Append the client cert and CA chain to get a full certificate chain
	clientChain := append(clientCert, []byte("\n")...)
	clientChain = append(clientChain, rootCert...)
	clientCerts, err := tls.X509KeyPair(clientChain, clientKey)
	if err != nil {
		fmt.Printf("Error loading client key pair: %v\n", err)
		os.Exit(1)
	}

	// DEBUG: Print client certificates and chain
	fmt.Println("Client Certificate and Chain:")
	for _, cert := range clientCerts.Certificate {
		parsedCert, err := x509.ParseCertificate(cert)
		if err != nil {
			fmt.Printf("Error parsing client certificate: %v\n", err)
			os.Exit(1)
		}
		fmt.Printf("\tSubject: %s\n", parsedCert.Subject)
	}

	// Create SSL keylog file
	keyLogFile, err := os.OpenFile(keylog, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		fmt.Printf("Error opening SSL keylog file")
		os.Exit(1)
	}
	fmt.Fprintf(keyLogFile, "# SSL/TLS secrets log file, generated by go\n")

	// Create a custom TLS config with specific versions and cipher suites
	tlsConfig := &tls.Config{
		Certificates: []tls.Certificate{clientCerts},
		ClientCAs:    rootCertPool,
		RootCAs:      rootCertPool,
		ServerName:   host, // Set the ServerName to the host you are connecting to
		MinVersion:   tls.VersionTLS12,
		MaxVersion:   tls.VersionTLS13,
		CipherSuites: []uint16{
			tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
			tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
			tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
			tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
		},
		KeyLogWriter: keyLogFile,
	}

	// Build the connection string
	connStr := fmt.Sprintf("host=%s port=%d dbname=%s user=%s sslmode=%s sslcert=%s sslkey=%s sslrootcert=%s",
		host, port, database, user, sslmode, sslcert, sslkey, sslrootcert)

	// Add the TLS config to the pgx config
	connConfig, err := pgx.ParseConfig(connStr)
	if err != nil {
		fmt.Printf("Error parsing connection string: %v\n", err)
		os.Exit(1)
	}
	connConfig.TLSConfig = tlsConfig

	conn, err := pgx.ConnectConfig(context.Background(), connConfig)
	if err != nil {
		fmt.Printf("Error opening database connection: %v\n", err)
		os.Exit(1)
	}
	defer conn.Close(context.Background())

	// Run a simple query to validate the connection
	var currentUser string
	err = conn.QueryRow(context.Background(), "SELECT current_user").Scan(&currentUser)
	if err != nil {
		fmt.Printf("Error running query: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Connected as user: %s\n", currentUser)
}

// readPGServiceConfig reads the PG service configuration from the given file for the specified service
func readPGServiceConfig(filePath, serviceName string) (map[string]string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, fmt.Errorf("could not open file: %v", err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	isServiceSection := false
	serviceConfig := make(map[string]string)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		if strings.HasPrefix(line, "[") && strings.HasSuffix(line, "]") {
			currentSection := line[1 : len(line)-1]
			isServiceSection = (currentSection == serviceName)
			continue
		}

		if isServiceSection {
			parts := strings.SplitN(line, "=", 2)
			if len(parts) != 2 {
				return nil, errors.New("invalid config line: " + line)
			}
			key := strings.TrimSpace(parts[0])
			value := strings.TrimSpace(parts[1])
			serviceConfig[key] = value
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading file: %v", err)
	}

	if len(serviceConfig) == 0 {
		return nil, fmt.Errorf("service '%s' not found in config", serviceName)
	}

	return serviceConfig, nil
}
